{
  "customInstructions": "You are assisting Team Wavelength 3572 with FIRST Robotics Competition (FRC) robot code development for the 2026 season using the AdvantageKit framework. This team has excellent coding practices from 2025 - maintain and build upon their patterns.\n\n# Team 3572's AdvantageKit Architecture (CRITICAL - Follow Exactly)\n\n## Subsystem Structure Pattern\nEach subsystem MUST follow this exact package structure:\n```\nsubsystems/subsystemname/\n├── SubsystemName.java           # Main subsystem extending SubsystemBase\n├── SubsystemNameIO.java         # IO interface with @AutoLog nested Inputs class\n├── SubsystemNameIOSpark.java    # Real hardware (REV Spark controllers)\n├── SubsystemNameIOVirtualSim.java or SubsystemNameIOSim.java  # Simulation\n├── SubsystemNameConstants.java  # All constants (CAN IDs, measurements, limits)\n└── SubsystemNameConfigs.java    # Spark motor configurations (PID, limits, etc.)\n```\n\n## IO Layer Requirements\n- Use `@AutoLog` annotation on nested Inputs class in IO interface\n- Real implementation: `SubsystemNameIOSpark` for REV Spark controllers\n- Sim implementation: `SubsystemNameIOVirtualSim` or full physics sim\n- All sensor readings go in AutoLogged Inputs\n- All actuator commands are methods on the IO interface\n- Use `@AutoLogOutput` in main subsystem for calculated/derived values\n\n# Team's Technology Stack\n- **Primary Motor Controllers**: REV Spark (via REVLib)\n- **Secondary**: CTRE devices via Phoenix 6 (Pigeon 2 gyro)\n- **Vision**: PhotonVision with pose estimation\n- **Autonomous**: PathPlanner 2025+ (with LocalADStarAK custom pathfinding)\n- **Drive**: Swerve drive with custom SparkOdometryThread\n- **Code Quality**: Spotless formatting, Lombok (@Getter, etc.)\n- **Logging**: URCL (Unofficial REV-Compatible Logger) for Spark details\n\n# Team's Advanced Patterns\n\n## 1. Composite Subsystems\nFor complex mechanisms (like 2025's CoralSystem with Arm+Elevator+Intake):\n- Create a parent subsystem that coordinates child subsystems\n- Use preset system (SubsystemPresets class) for coordinated positions\n- Each component still has its own IO layer\n\n## 2. Strategy Pattern for Autonomous\nUse strategy pattern for different autonomous behaviors:\n- Create AlignmentStrategy interface or similar\n- Implement concrete strategies for different scenarios\n- Use StrategyManager to select and execute strategies\n\n## 3. Thread Priority Management\nIn Robot.java robotPeriodic():\n```java\nThreads.setCurrentThreadPriority(true, 99);  // Before scheduler\nCommandScheduler.getInstance().run();\nThreads.setCurrentThreadPriority(false, 10); // After scheduler\n```\n\n## 4. Odometry Threading\nFor swerve drive, use SparkOdometryThread pattern for higher frequency odometry updates\n\n## 5. Vision Fusion\nIntegrate vision pose estimates into SwerveDrivePoseEstimator with configurable standard deviations\n\n## 6. Health Monitoring\n- Create Alert objects for hardware disconnects\n- Implement odometry health monitoring\n- Log system status continuously\n\n## 7. Utility Classes\nCreate util/ package for:\n- Alignment calculations and target selection\n- Custom dashboard helpers (Elastic)\n- Robot status tracking\n- Reusable math/geometry helpers\n\n# Code Organization\n\n## Package Structure\n```\nfrc.robot/\n├── subsystems/\n│   ├── drive/              # Swerve drive (reusable from 2025)\n│   │   ├── Drive.java\n│   │   ├── Module.java\n│   │   ├── ModuleIO.java\n│   │   ├── ModuleIOSpark.java\n│   │   ├── ModuleIOSim.java\n│   │   ├── GyroIO.java\n│   │   ├── GyroIOPigeon2.java\n│   │   ├── DriveConstants.java\n│   │   └── SparkOdometryThread.java\n│   ├── vision/\n│   │   ├── Vision.java\n│   │   ├── VisionIO.java\n│   │   ├── VisionIOPhotonVision.java\n│   │   ├── VisionIOPhotonVisionSim.java\n│   │   └── VisionConstants.java\n│   └── [game-specific subsystems]/\n├── commands/              # Command classes\n├── alignment/ or strategies/  # Strategy pattern implementations\n├── util/                  # Utility classes\n├── Constants.java         # Global constants (Mode, tuningMode, isCompetition)\n├── FieldConstants.java    # Field dimensions and target positions\n├── Robot.java             # URCL setup, thread priority, logging config\n├── RobotContainer.java    # Subsystem instantiation and bindings\n└── ButtonsAndDashboardBindings.java  # Separate bindings file\n```\n\n## Constants Pattern\n- `Constants.java`: Mode enum (REAL/SIM/REPLAY), tuningMode flag, isCompetition flag\n- `SubsystemConstants.java`: CAN IDs, physical measurements, PID values, limits\n- `SubsystemConfigs.java`: Spark motor config objects (closures for configuration)\n- `FieldConstants.java`: Field dimensions, target poses, alliance-specific positions\n\n# REV Spark Best Practices\n- Use SparkBase configuration pattern with closures\n- Configure everything in one block before enabling\n- Use URCL for detailed Spark telemetry logging\n- Prefer Spark onboard PID when possible\n- Use MAXMotion for smooth motion profiling on elevators\n\n# PhotonVision Integration\n- Check if vision estimates are valid before using\n- Filter by tag count and ambiguity\n- Use different standard deviations based on distance/quality\n- Can toggle vision on/off (setVisionOn/setVisionOff)\n\n# Lombok Usage\n- Use `@Getter` to reduce boilerplate\n- Use `@AutoLogOutput` for auto-logging return values\n- Keep usage simple and readable\n\n# Alliance Awareness\n- Always account for field flipping (red vs blue alliance)\n- Use AllianceFlipUtil or similar for coordinate transformations\n- Test autonomous on both sides of the field\n\n# Build Commands (already aliased)\n- `./gradlew build` - Compile and check\n- `./gradlew deploy` - Deploy to robot\n- `./gradlew simulateJava` - Run simulation\n- `./gradlew spotlessApply` - Format code (pre-commit hook does this)\n\n# Competition Readiness\n- Set `isCompetition = true` in Constants.java for competitions\n- Disable tuningMode for competitions\n- Test all autonomous modes\n- Verify all CAN IDs match physical robot\n- Check battery voltage thresholds\n- Validate vision pipeline selection\n\n# When Creating New Subsystems\n1. Create subsystem package with all 5 files (see structure above)\n2. Define IO interface with @AutoLog Inputs first\n3. Implement IOSpark for real hardware\n4. Implement IOVirtualSim or physics sim\n5. Create Constants file with all magic numbers\n6. Create Configs file for Spark configurations\n7. Write main Subsystem class using IO abstraction\n8. Add to RobotContainer\n9. Create commands for subsystem\n10. Add dashboard logging and tuning\n\n# Reference 2025 Code\nWhen unsure about patterns, reference C:\\FRC Projects\\Robot-2025:\n- Drive subsystem for swerve patterns\n- Vision subsystem for PhotonVision integration\n- Coral system for composite subsystem pattern\n- Alignment strategies for strategy pattern\n- Utility classes for reusable helpers",
  "aliases": {
    "build": "./gradlew build",
    "deploy": "./gradlew deploy",
    "sim": "./gradlew simulateJava",
    "format": "./gradlew spotlessApply",
    "clean": "./gradlew clean"
  }
}
